# گزارش پروژه پایانی درس پایگاه داده پیشرفته
# Havirkesht

**Advanced Database Project: LU 1404-1**

**FastAPI + PostgreSQL**


***دانشجو:** سعید حق نظری

**درس:** پایگاه داده پیشرفته

**استاد:** دکتر آرمین رشنو

**نیمسال:** پاییز ۱۴۰۴

## معرفی پروژه
این پروژه مربوط به پیاده‌سازی بخش **Backend** سامانه Havirkesht می‌باشد که با استفاده از فریم‌ورک **FastAPI** توسعه داده شده است. هدف اصلی این پروژه، طراحی و استقرار یک وب‌سرویس امن، مقیاس‌پذیر و قابل نگهداری با استفاده از فناوری‌های مدرن DevOps از جمله Docker، Nginx و CI/CD است.
یک پروژه با نام تجاری هاویرکشت وجود دارد که به کشاورزان دارای کشت قراردادی سرویس می دهد. هاویرکشت سامانه ای مبتنی بر آخرین فناوریهای روز است که به پیمانکاران و کشاورزان کشت چغندر قند در جهت رصد و پایش محصولات و صورتحسا بهای مالی خود کمک میکند. سامانه هاویر کشت بهصورت لحظ های و آنلاین آخرین تغییرات را به اطلاع کشاورزان میرساند و شفافیت لازم در صورتحسا بهای آ نها ایجاد میکند. این سامانه وزن بار، عیار، درصد افت، قیمت تمام شده، سهمیه قند و تفاله، بذر دریافتی و دیگر اقلام هر کشاورز را به صورت شفاف در دسترس آنها قرار می دهد.


## فاز اول: بررسی، تست و مستندسازی APIهای سمت سرور با استفاده از Swagger

برای تعدادی API موارد زیر بررسی می­گردد:
- نام API
- متد HTTP (GET, POST, PUT, DELETE)
- آدرس Endpoint
- پارامترهای ورودی(Path Parameters، Query Parameter، Request Body)
- خروجی (Response)
- کد وضعیت (Status Code)
- ساختار داده برگشتی

با استفاده از قابلیت **Try it out** در Swagger، درخواست‌ها ارسال و پاسخ‌های دریافتی بررسی شدند. این تست‌ها شامل موارد زیر بود:
- دریافت لیست داده‌ها
- مشاهده اطلاعات یک رکورد خاص
- بررسی پاسخ‌های موفق و ناموفق

در ادامه API های مرتبط با چند موجودیت از جمله Auth، Users، Car، Driver، Factory، Seed و ... را به طور کامل بررسی کرده و لیست همه API ها در یک جدول شامل نام، ورودی، خروجی و ... مستند سازی می­شود.

### 1- Auth

![](./images/11.png)


APIهای Authentication مسئول مدیریت احراز هویت کاربران، صدور توکن‌های دسترسی، تمدید توکن، خروج از سیستم و تغییر رمز عبور می‌باشند. کاربر ابتدا از طریق /token احراز هویت می‌شود، سپس یک Access Token دریافت می‌کند که این توکن در هدر درخواست‌های بعدی استفاده می‌شود و سرور با بررسی توکن، اجازه یا عدم اجازه دسترسی را تعیین می‌کند. این فرآیند مطابق با استاندارد OAuth2(Password Grant Type) و مبتنی بر JWT پیاده‌سازی شده است.


| نام API                | Endpoint       |      | ورودی                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | خروجی                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| ---------------------- | -------------- | ---- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Path                   | Method         |      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Login For Access Token | /token         | POST | داده ورودی به جای JSON از نوع application/x-www-form-urlencoded است که مطابق استاندارد OAuth2 است و برای ارسال داده‌های ساده مانند نام کاربری و رمز عبور مناسب‌تر است.<br><br>پارامترهای اصلی (اجباری):<br><br>username: نام کاربری ثبت‌شده در سیستم  <br>password: رمز عبور کاربر<br><br>پارامترهای تکمیلی (اختیاری):<br><br>grant_type: نوع روش احراز هویت (معمولاً password)<br><br>scope: محدوده دسترسی کاربر<br><br>client_id: شناسه کلاینت<br><br>client_secret: رمز کلاینت                                  | 1- پاسخ موفق:<br><br>Status Code: 200 OK<br><br>**{**<br><br>  **"access_token": "string",**<br><br>  **"refresh_token": "string",**<br><br>  **"token_type": "string"**<br><br>**}**<br><br>access_token: توکن اصلی دسترسی به APIها است که در هدر Authorization ارسال می‌شود. دارای زمان انقضا است و بیانگر هویت و سطح دسترسی کاربر می‌باشد.<br><br>refresh_token: توکن ثانویه‌ای است که برای تمدید access_token استفاده می‌شود. امنیت سیستم را افزایش می‌دهد و نیاز به ورود مجدد کاربر را کاهش می‌دهد.<br><br>token_type: مقدار آن bearer است که نشان می‌دهد توکن باید در هدر Authorization به‌صورت Bearer ارسال شود.<br><br>2- Validation Error: 422<br><br>زمانی رخ می‌دهد که داده ورودی نامعتبر یا ناقص باشد. |
| Refresh Access Token   | /refresh-token | POST | **Query Parameter:**<br><br>refresh_token: برای تمدید توکن دسترسی (Access Token) بدون نیاز به ورود مجدد کاربر طراحی شده است چون Access Tokenها در صورت سرقت، خطر امنیتی ایجاد می‌کنند. برای حل این مشکل Access Token کوتاه‌مدت تعریف می‌شود و با استفاده از Refresh Token، می‌توان Access Token جدید گرفت بدون اینکه کاربر دوباره لاگین کند. وظیفه /refresh-token این است که یک Refresh Token معتبر دریافت می‌کند و اعتبار آن را بررسی کرده و در صورت معتبر بودن Access Token و Refresh Token جدید را صادر می‌کند. | 1- پاسخ موفق:<br><br>Status Code: 200 OK<br><br>**{**<br><br>  **"access_token": "string",**<br><br>  **"refresh_token": "string",**<br><br>  **"token_type": "string"**<br><br>**}**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| Logout User            | / logout       | POST | **Query Parameters:**<br><br>access_token<br><br>refresh_token<br><br>حداقل یکی از این دو توکن باید ارسال شود.<br><br>ارسال هر دو مجاز است و حتی توصیه می‌شود.                                                                                                                                                                                                                                                                                                                                                     | 1- پاسخ موفق:<br><br>Status Code: 200 OK<br><br>**{**<br><br>  **"message": "string"**<br><br>**}**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |


Logout در سیستم‌های مبتنی بر JWT، به‌معنای بی‌اعتبارسازی توکن‌ها است، نه پایان یک session سمت سرور. در سیستم‌های سنتی(Session-based) با Logout، session روی سرور حذف می‌شود ولی در سیستم‌های Token-based(JWT) توکن‌ها به‌صورت Stateless هستند و سرور به‌صورت پیش‌فرض توکن را نگه نمی‌دارد بنابراین برای Logout باید توکن‌ها در یک Blacklist ثبت شوند. این Endpoint یک یا هر دو نوع توکن Access Token و Refresh Token را دریافت می‌کند و آن‌ها را در لیست سیاه(Blacklist) قرار می‌دهد از این پس، حتی اگر توکن هنوز منقضی نشده باشد، دیگر معتبر نخواهد بود.

### 2- Cars

![](./images/12.png)


موجودیت Car یکی از موجودیت‌های پایه‌ای در سامانه هاویرکشت است. این موجودیت برای نگهداری اطلاعات مربوط به خودروها استفاده می‌شود و نقش کلیدی در ارتباط با موجودیت‌های دیگر مانند Driver دارد.



|   |   |   |   |   |   |
|---|---|---|---|---|---|
|نام API|Endpoint|   |ورودی|خروجی|توضیحات|
|Path|Method|
|Create Car|/cars/|POST|**Request body:**<br><br>**{**<br><br>  **"name": "string"**<br><br>**}**|1- پاسخ موفق:<br><br>Status Code: 201 Created<br><br>**{**<br><br>  **"name": "string",**<br><br>  **"id": 0,**<br><br>  **"created_at": "string"**<br><br>**}**<br><br>2- Validation Error: 422<br><br>زمانی رخ می‌دهد که داده ورودی نامعتبر یا ناقص باشد.|این API برای ثبت یک خودرو جدید در سیستم استفاده می‌شود. اطلاعات خودرو از طریق Request Body و در قالب JSON ارسال می‌گردد.|
|Get All Cars|/cars/|GET|**Query Parameters:**<br><br>1- Page: شماره صفحه داده‌ها<br><br>·       مقدار پیش‌فرض: 1<br><br>·       حداقل مقدار: 1<br><br>·        <br><br>2-size: تعداد آیتم‌ها در هر صفحه<br><br>·       مقدار پیش‌فرض: 50<br><br>·       حداقل: 1<br><br>·       حداکثر: 100<br><br>·        <br><br>3-sort_by: تعیین فیلد مرتب‌سازی<br><br>·       می‌تواند تهی(null) باشد.<br><br>·        <br><br>4- sort_order: ترتیب مرتب‌سازی<br><br>·       **pattern: ^(asc\|desc)$**<br><br>·       یعنی فقط مقادیر asc یا desc مجاز هستند.<br><br>می‌تواند تهی(null) باشد.<br><br>·        <br><br>5- search: جستجوی متنی در نام خودروها<br><br>می‌تواند تهی(null) باشد.|1- پاسخ موفق:<br><br>Status Code: 200 OK<br><br>**{**<br><br>  **"total": 0,**<br><br>  **"size": 0,**<br><br>  **"pages": 0,**<br><br>  **"items": [**<br><br>    **{**<br><br>      **"name": "string",**<br><br>      **"id": 0,**<br><br>      **"created_at": "string"**<br><br>    **}**<br><br>  **]**<br><br>**}**<br><br>·       توضیح فیلدها:<br><br>·       total: تعداد کل خودروها<br><br>·       size: تعداد آیتم‌های هر صفحه<br><br>·       pages: تعداد کل صفحات<br><br>·       items: لیست خودروهای صفحه جاری<br><br>2- Validation Error: 422|این API برای دریافت لیست خودروهای ثبت‌شده در سیستم استفاده می‌شود و از قابلیت‌های صفحه‌بندی، مرتب‌سازی و جستجو پشتیبانی می‌کند.|
|Get Car By Id|/cars/{car_id}|GET|**Path Parameter:**<br><br>car_id: شناسه خودرو  <br>این پارامتر اجباری است|1- پاسخ موفق:<br><br>Status Code: 200 OK<br><br>**{**<br><br>  **"name": "string",**<br><br>  **"id": 0,**<br><br>  **"created_at": "string"**<br><br>**}**|این API  برای دریافت اطلاعات یک خودروی خاص بر اساس شناسه یکتا استفاده می‌شود. شناسه خودرو به‌عنوان Path Parameter ارسال می‌گردد.|
|Update Car|/cars/{car_id}|PUT|**Path Parameter:**<br><br>car_id: شناسه خودرو<br><br>این پارامتر اجباری است<br><br>**Request body:**<br><br>**{**<br><br>  **"name": "string"**<br><br>**}**|1- پاسخ موفق:<br><br>Status Code: 200 OK<br><br>**{**<br><br>  **"name": "string",**<br><br>  **"id": 0,**<br><br>  **"created_at": "string"**<br><br>**}**|این API برای به‌روزرسانی اطلاعات یک خودرو موجود استفاده می‌شود. شناسه خودرو به‌عنوان Path Parameter و نام جدید از طریق Request Body ارسال می‌شود.|
|Delete Car|/cars/{car_id}|DELETE|**Path Parameter:**<br><br>car_id: شناسه خودرو<br><br>این پارامتر اجباری است.|**{**<br><br>  **"message": "string"**<br><br>**}**|این API برای حذف یک خودرو از سیستم استفاده می‌شود. در صورت موفقیت، پیام تأیید عملیات حذف بازگردانده می‌شود.|


**اجرا و تست چند نمونه از** **API** **های موجودیت** **Cars**


 **ایجاد خودرو(Create Car): POST /cars/**


این API برای ثبت یک نوع وسیله نقلیه جدید در پایگاه داده است.
ورودی: این ورودی از نظر ساختار و نوع داده کاملاً صحیح بوده و با Schema تعریف‌شده در Swagger مطابقت دارد.
در این درخواست، بدنه JSON شامل یک فیلد به نام name است که نام خودرو را مشخص می‌کند.

![](./images/13.png)


![](./images/14.png)



وجود هدر Authorization نشان می‌دهد که این Endpoint نیازمند احراز هویت است و فقط کاربران مجاز اجازه اجرای آن را دارند.


خروجی:


![](./images/15.png)



کد وضعیت **401 Unauthorized** زمانی بازگردانده می‌شود که کاربر احراز هویت نشده باشد یا اطلاعات احراز هویت او معتبر نباشد. در اینجا، پیام خطا به‌وضوح بیان می‌کند که توکن احراز هویت(JWT) منقضی شده است.

توکن JWT دارای یک زمان انقضا(exp) است. پس از گذشت این زمان سرور دیگر آن توکن را معتبر نمی‌داند بنابراین هر درخواست با آن توکن رد می‌شود و خطای 401 بازگردانده می‌شود.

پس از Authentication و اجرای API بالا، خروجی زیر برگردانده می­شود:



![](./images/17.png)


در این مرحله، درخواست ایجاد خودرو با موفقیت توسط سرور پردازش شده و پاسخ مناسب بازگردانده شده است. کد وضعیت **201** **Created** نشان‌دهنده آن است که یک منبع جدید با موفقیت در سیستم ایجاد شده است.

**توضیح فیلدهای خروجی:**
- فیلد name: این فیلد نشان‌دهنده نام خودروی ثبت‌شده در سیستم است. مقدار آن دقیقاً برابر با داده ارسالی در درخواست می‌باشد که بیانگر ذخیره صحیح اطلاعات است.
- فیلد id: این فیلد شناسه یکتای خودرو است که توسط سیستم به‌صورت خودکار تولید شده و کلید اصلی (Primary Key) در پایگاه داده محسوب می‌شود و برای ارجاع در سایر موجودیت‌ها(مانند Driver) استفاده می‌شود.
- فیلد created_at: این فیلد زمان ایجاد رکورد را نشان می‌دهد. ضمنا تاریخ به‌صورت شمسی(Jalali) نمایش داده شده است.

**دریافت لیست خودروها(Get All Cars): GET /cars/**

این Endpoint برای دریافت لیست خودروهای ثبت‌شده در سیستم استفاده می‌شود و از قابلیت‌های صفحه‌بندی، مرتب‌سازی و جستجو پشتیبانی می‌کند.

ورودی:


![](./images/18.png)


![](./images/19.png)


در این اجرا، چندین Query Parameter به‌صورت هم‌زمان استفاده شده‌اند که هر کدام نقش مشخصی در کنترل خروجی دارند.

پارامترهای استفاده‌شده:

|   |   |   |
|---|---|---|
|**پارامتر**|**مقدار**|**توضیح**|
|page|1|دریافت صفحه اول داده‌ها|
|size|5|تعداد آیتم در هر صفحه|
|sort_by|created_at|مرتب‌سازی بر اساس تاریخ ایجاد|
|search|تریلی|جستجو بر اساس نام خودرو|

عدم ارسال پارامتر sort_order باعث اعمال ترتیب پیش‌فرض سیستم شده است.


خروجی:


![](./images/20.png)


کد وضعیت OK 200 بیانگر آن است که درخواست با موفقیت پردازش شده و داده‌ها بدون خطا به کلاینت بازگردانده شده‌اند.

تحلیل فیلدهای خروجی:
- فیلد total: عدد 3 نشان می‌دهد که در کل پایگاه داده، سه خودرو وجود دارند که شرط جستجوی «تریلی» را برآورده می‌کنند.
- فیلد size: مقدار 5 بیانگر حداکثر تعداد رکورد در هر صفحه است. در این اجرا، تعداد نتایج کمتر از اندازه صفحه بوده است.
- فیلد pages: عدد 1 نشان می‌دهد که تمامی نتایج در یک صفحه قابل نمایش هستند و نیازی به صفحه‌بندی بیشتر وجود ندارد.
- فیلد items: لیست خودروهایی است که شرط جستجو را برآورده کرده‌اند. هر آیتم شامل نام خودرو، شناسه یکتا و تاریخ ایجاد می­باشد.

**دریافت خودرو بر اساس شناسه: GET /cars/{car_id}**

این Endpoint برای دریافت اطلاعات یک خودرو خاص بر اساس شناسه یکتا طراحی شده است.  
در این API شناسه خودرو از طریق **Path Parameter** دریافت می‌شود و در صورت موفقیت فقط یک رکورد مشخص از پایگاه داده در قالب JSON بازیابی می‌گردد.

ورودی:

![](./images/21.png)


مقدار car_id = 5 نشان‌دهنده شناسه خودرویی است که کاربر قصد دریافت اطلاعات آن را دارد. استفاده از Path Parameter بیانگر عملیات روی یک منبع مشخص(Resource-Oriented) است.

خروجی:


![](./images/22.png)


کد وضعیت **404 Not Found** زمانی بازگردانده می‌شود که:
- درخواست از نظر ساختار صحیح است.
- کاربر مجاز به انجام عملیات است.
- اما منبع درخواستی در سیستم وجود ندارد.

در این سناریو:
- شناسه 5 در پایگاه داده ثبت نشده است.
- بنابراین سرور قادر به یافتن خودرو موردنظر نبوده است.


**ویرایش نام یک خودرو(Update Car): PUT /cars/{car_id}**

این API برای به‌روزرسانی اطلاعات یک خودرو موجود در سیستم طراحی شده است.
در این Endpoint:
- شناسه خودرو از طریق Path Parameter دریافت می‌شود.
- نام جدید خودرو از طریق Request Body ارسال می‌گردد.


ورودی:

![](./images/23.png)

![](./images/24.png)

خروجی:

![](./images/25.png)

کد وضعیت OK 200 نشان‌دهنده آن است که عملیات ویرایش با موفقیت انجام شده است.
**تحلیل فیلدهای پاسخ:
- فیلد name: نام خودرو که پس از عملیات به‌روزرسانی با موفقیت تغییر کرده است.
- فیلد id: شناسه خودرو که بدون تغییر باقی مانده است، زیرا این فیلد کلید اصلی رکورد محسوب می‌شود.
- فیلد created_at: زمان ایجاد خودرو است که با اجرای این API تغییر نمی­کند.

هر دو ورودی این API اجباری هستند و نباید خالی بشند.
در صورتی که مقدار پارامتر car_id در جدول Car وجود نداشته باشد خطای 404 با یک بدنه JSON به شکل زیر برگردانده می­شود.


![](./images/26.png)


در خطای 404 منبع موردنظر وجود ندارد ولی در خطای 422 مقدار ورودی نامعتبر است.
مثلا در این درخواست فیلد name باید از نوع **رشته****(string)** باشد اما مقدار عددی(integer) ارسال شده است و این مغایرت باعث بروز خطای اعتبارسنجی شده است.

![](./images/27.png)

کد **422 Unprocessable Entity** زمانی استفاده می‌شود که:
- ساختار کلی درخواست صحیح است.
- داده‌ها قابل پردازش هستند.
- اما قوانین اعتبارسنجی(Validation Rules) نقض شده‌اند.

در این مثال بدنه JSON معتبر است اما نوع داده فیلد name نادرست است.


**3-**   **Driver**

یکی از بخش‌های مهم سامانه هاویرکشت، مدیریت اطلاعات رانندگان (Driver) است. این API ها امکان انجام عملیات کامل CRUD(Create, Read, Update, Delete) بر روی اطلاعات رانندگان را فراهم می‌کنند.

موجودیت راننده شامل فیلدهای زیر است:

|   |   |
|---|---|
|**توضیح**|**فیلد**|
|نام راننده|name|
|نام خانوادگی|last_name|
|کد ملی|national_code|
|شماره تماس|phone_number|
|شناسه خودرو(کلید خارجی)|car_id|
|شماره پلاک|license_plate|
|ظرفیت حمل|capacity_ton|
|شناسه یکتا|id|
|زمان ایجاد رکورد|created_at|


![](./images/28.png)



| نام API         | Endpoint |      | ورودی                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | خروجی                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | توضیحات                                                                                                                                                                                                    |
| --------------- | -------- | ---- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Create Driver   | /driver/ | POST | **Request body:**<br><br>**{**<br><br>  **"name": "string",**<br><br>  **"last_name": "string",**<br><br>  **"national_code": "string",**<br><br>  **"phone_number": "string",**<br><br>  **"car_id": 0,**<br><br>  **"license_plate": "string",**<br><br>  **"capacity_ton": 0**<br><br>**}**                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | 1- پاسخ موفق:<br><br>Status Code: 201 Created<br><br>**{**<br><br>  **"name": "string",**<br><br>  **"last_name": "string",**<br><br>  **"national_code": "string",**<br><br>  **"phone_number": "string",**<br><br>  **"car_id": 0,**<br><br>  **"license_plate": "string",**<br><br>  **"capacity_ton": 0,**<br><br>  **"id": 0,**<br><br>  **"created_at": "string",**<br><br>  **"car_name": "string"**<br><br>**}**                                                                                                                                       | این API برای ثبت یک راننده جدید در سیستم استفاده می‌شود. اطلاعات راننده از طریق Request Body و در قالب JSON ارسال می‌گردد.                                                                                 |
| Get All Drivers | /driver/ | GET  | **Query Parameters:**<br><br>1- Page: شماره صفحه داده‌ها<br><br>·       مقدار پیش‌فرض: 1<br><br>·       حداقل مقدار: 1<br><br>·        <br><br>2-size: تعداد آیتم‌ها در هر صفحه<br><br>·       مقدار پیش‌فرض: 50<br><br>·       حداقل: 1<br><br>·       حداکثر: 100<br><br>·        <br><br>3-sort_by: تعیین فیلد مرتب‌سازی<br><br>·       می‌تواند تهی(null) باشد.<br><br>·        <br><br>4- sort_order: ترتیب مرتب‌سازی<br><br>·       **pattern: ^(asc\|desc)$**<br><br>·       یعنی فقط مقادیر asc یا desc مجاز هستند.<br><br>می‌تواند تهی(null) باشد.<br><br>·        <br><br>5- search: جستجوی متنی در نام خودروها<br><br>می‌تواند تهی(null) باشد.<br><br>6- car_id: فیلتر کردن رانندگان بر اساس شناسه خودرو(نوع خودرو)<br><br>می‌تواند تهی(null) باشد. | **{**<br><br>  **"total": 0,**<br><br>  **"size": 0,**<br><br>  **"pages": 0,**<br><br>  **"items": [**<br><br>    **{**<br><br>      **"name": "string",**<br><br>      **"last_name": "string",**<br><br>      **"national_code": "string",**<br><br>      **"phone_number": "string",**<br><br>      **"car_id": 0,**<br><br>      **"license_plate": "string",**<br><br>      **"capacity_ton": 0,**<br><br>      **"id": 0,**<br><br>      **"created_at": "string",**<br><br>      **"car_name": "string"**<br><br>    **}**<br><br>  **]**<br><br>**}** | این API برای دریافت لیست تمامی رانندگان ثبت‌شده در سیستم استفاده می‌شود. این سرویس امکان **صفحه‌بندی****(Pagination)**، **مرتب‌سازی****(Sorting)** و **فیلتر کردن****(Filtering)** داده‌ها را فراهم می‌کند |





## فاز دوم: بررسی کامل صفحات سمت کاربر (Client Side) سیستم و تحلیل نحوه‌ی ارتباط هر صفحه با APIهای سمت سرور (Backend) می‌باشد.  
 
در این مرحله مشخص می‌شود که هر صفحه از رابط کاربری، هنگام بارگذاری یا انجام عملیات مختلف، کدام Endpointهای API را فراخوانی می‌کند و چه داده‌هایی بین کلاینت و سرور رد و بدل می‌شود.

هدف این مرحله:
درک کامل ارتباط Frontend و Backend
شناسایی APIهای مصرف‌شده توسط هر صفحه
تسلط عملی بر ابزار Inspect مرورگر و تب Network
برای هر Request موارد زیر استخراج می‌شود:

**Method (GET, POST, PUT, DELETE)**

**URL (Endpoint)**

**Request Parameters**

**Request Body**

**Response Status Code**

**Response Body**



**1- صفحه ورود کاربر


![](./images/46.png)



![](./images/47.png)





در این سناریو، هنگام ورود به سیستم، نام کاربری را به ‌اشتباه وارد کردم در نتیجه، دو درخواست متوالی به APIهای مربوط به احراز هویت ارسال شده است:
- درخواست دریافت Access Token
- درخواست Refresh Token
هر دو درخواست با خطا مواجه شده‌اند اما با کدهای وضعیت متفاوت.
کد وضعیت 401 Unauthorized به‌صورت استاندارد در پروتکل HTTP به این معناست که سرور قادر به احراز هویت درخواست‌کننده نیست.

پس از شکست Login، تلاش می‌کند توکن قبلی را تمدید کند. اما چون توکنی وجود ندارد، درخواست Refresh نیز شکست می‌خورد. کد وضعیت 422 به این معناست که سرور درخواست را از نظر ساختار قابل پردازش می‌داند، اما داده‌های ارسال‌شده از نظر منطقی معتبر نیستند.



![](./images/38.png)


![](./images/39.png)


![](./images/41.png)


![](./images/42.png)


![](./images/43.png)


![](./images/44.png)


![](./images/45.png)



**2- ثبت نوع خودرو جدید


![](./images/33.png)


![](./images/34.png)


![](./images/35.png)


![](./images/36.png)


![](./images/37.png)


![](./images/32.png)




**3- حذف خودرو


![](./images/31.png)


![](./images/30.png)



ثبت استان تکراری با خطای 500 پاسخ داده میشه! 409 باید باشد.


![](./images/29.png)



**ضعفهای API های هاویرکشت در بررسی های بعمل آمده:**
- ثبت استان تکراری با خطای 500 پاسخ داده میشه در حالی که باید 409 باشه.
- برای حذف استان و شهر و روستا از نام استفاده میکنه نه Id.
- شهر تکراری در استان های مختلف رو نمیپذیره در حالی که در واقعیت اینطور نیست.
- در ثبت روستا هم ایراد داره. هر ورودی بدیم خطای 409 میده یعنی روستا تکراری است.


## فاز سوم: پیاده‌سازی پایگاه داده رابطه‌ای

هدف این فاز، پیاده‌سازی یک پایگاه داده رابطه‌ای بر اساس نمودار ERD ارائه‌شده است. در این مرحله، جداول، فیلدهای هر جدول و روابط بین جداول به‌صورت کامل در یک DBMS پیاده‌سازی شده و آماده اتصال به Backend می‌گردند.

![](./images/erd.JPG)

در این پروژه از PostgreSQL استفاده می­کنیم و برای اتصال دیتابیس به Backend، از ORM(FastAPI) استفاده می­کنیم.  
پس از تعریف مدل‌ها جداول به‌صورت خودکار در پایگاه داده ایجاد شده و روابط بین آنها شکل می­گیرد.

به‌منظور پیاده‌سازی انواع مختلف روابط در پایگاه داده رابطه‌ای(One-to-Many، One-to-One و Many-to-Many)، جداول زیر انتخاب شده‌اند:

- roles
- users
- provinces
- cities
- villages
- crop_years
- factories
- measure_units
- seeds
- pesticides
- factory_seed
- factory_pesticide

چند مثال از انواع روابط در جدول زیر آمده است:

|   |   |
|---|---|
|جداول|نوع رابطه|
|provinces–cities<br><br>cities–villages<br><br>roles–users|One-to-Many|
|users–factories|One-to-One|
|factories–seeds<br><br>factories–pesticides|Many-to-Many|

***ساختار پروژه HAVIRKESHT:***


![](./images/48.png)



ساختار پروژه به‌صورت ماژولار و مطابق با استانداردهای FastAPI طراحی شده است. این ساختار باعث افزایش خوانایی کد، قابلیت توسعه و نگهداری آسان‌تر سیستم می­شود.

**پوشه models:**
در پوشه models، ساختار جداول پایگاه داده با استفاده از ORM پیاده‌سازی شده است. و هر موجودیت یک مدل SQLAlchemy است.

**پوشه schemas:**
برای جداسازی لایه API از پایگاه داده و ورودی و خروجی API، از Schemaهای Pydantic استفاده می­شود.

**پوشه routes:**
مسیرهای API به‌صورت ماژولار در پوشه routes پیاده‌سازی شده‌اند.( EndPointهای FastAPI)

**فایل db.py:**
اتصال به پایگاه داده شامل Engine، Base و مدیریت Sessionها در فایل db.py انجام می­شود.

**فایل config.py:**
به‌عنوان محل نگهداری تنظیمات و پیکربندی‌های اصلی سیستم در نظر گرفته شده و ایجاد شیء app در این فایل، امکان مدیریت متمرکز تنظیمات سطح برنامه را فراهم می‌کند. به‌منظور افزایش نظم ساختاری و تفکیک مسئولیت‌ها، شیء اصلی برنامه FastAPI در فایل config.py ایجاد شده است. این تصمیم باعث شده است که تنظیمات کلی برنامه، از جمله عنوان، توضیحات، نسخه نرم‌افزار و پیکربندی‌های مربوط به چرخه عمر برنامه، در یک مکان متمرکز قرار گیرند.

**فایل main.py:**
نقش نقطه ورود (Entry Point) برنامه را ایفا کرده و وظیفه اجرای برنامه و راه‌اندازی سرویس را بر عهده دارد.*

**فایل requirements.txt:**
کتابخانه‌های مورد استفاده پروژه در فایل requirements.txt مشخص شده‌اند.

***شروع پیاده‌سازی پایگاه داده با SQLAlchemy:***
مطابق با Best Practice در طراحی پایگاه داده و ORM نام‌گذاری جداول پایگاه داده با حروف کوچک و به‌صورت جمع (Plural) انجام شده زیرا هر جدول مجموعه‌ای از رکوردها را نگهداری می‌کند. در مقابل، نام کلاس‌های مدل در ORM به‌صورت مفرد با حرف اول بزرگ در نظر گرفته شده است.

app/

├── models/

│   ├── provinces.py   → class Province

│   └── cities.py      → class City

│

├── schemas/

│   ├── provinces.py   → ProvinceCreate, ProvinceOut

│   └── cities.py      → CityCreate, CityOut

│

├── routes/

│   ├── provinces.py   → /provinces

│   └── cities.py      → /cities


ابتدا برای استفاده از PostgreSQL به یک DB driver نیاز داریم. رایج‌ترین انتخاب:


```bash
pip install psycopg2-binary
```



باید در PostgreSQL دیتابیس رو بسازیم:

```sql
CREATE DATABASE havirkesht_db;
```

سپس:
```sql
GRANT ALL PRIVILEGES ON DATABASE havirkesht_db TO saeed;
```
فایل db.py:
```python
from typing import Annotated
from fastapi import Depends
from sqlalchemy import create_engine
from sqlalchemy.orm import Session, sessionmaker, declarative_base

DATABASE_URL = "postgresql://saeed:123456@localhost:5432/havirkesht_db"
engine = create_engine(
    DATABASE_URL,
    echo=True
)

SessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine
)

Base = declarative_base()
def create_db_and_tables():
    Base.metadata.create_all(bind=engine)
def get_session():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

SessionDep = Annotated[Session, Depends(get_session)]
```

کلاس Base در واقع یک کلاس پایه‌ی declarative هست که از SQLAlchemy می‌آید و به مدل‌ها میگه که این‌ها جداول پایگاه داده هستند.

برای هر موجودیت یک فایل مدل، یک شما و یک روت می سازیم.

**مدل(Model) City:
```python
from ..db import Base as SQLAlchemyBase
from sqlalchemy.orm import Mapped, mapped_column, relationship
from sqlalchemy import Integer, String, ForeignKey, DateTime, func

class City(SQLAlchemyBase):

    __tablename__ = "cities"
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    city: Mapped[str] = mapped_column(String, nullable=False, unique=True)
    province_id: Mapped[int] = mapped_column(ForeignKey("provinces.id"), nullable=False)
    created_at: Mapped[DateTime] = mapped_column(DateTime(timezone=True), server_default=func.now())
    province = relationship("Province", back_populates="cities")
```


- برای ساخت مدل ها وقتی از Base ارث‌بری می‌کنیم، SQLAlchemy متدها و ویژگی‌های لازم برای ایجاد جدول، query و commit به دیتابیس رو به مدل اضافه می‌کنه. بعد با ارث‌بری از Base، هر کلاس به یک جدول در دیتابیس تبدیل می‌شه و می‌تونه با ORM تعامل داشته باشه.

- از Mapped  و mapped_column برای تعریف تایپ‌دار و استاندارد ستون‌های جدول در ORM جدید SQLAlchemy استفاده می‌شوند. Mapped برای تایپ‌دهی فیلد ORM و mapped_column برای تعریف ستون دیتابیس در SQLAlchemy جدید است.

|                      |                 |
| -------------------- | --------------- |
| نقش                  | بخش             |
| نوع پایتونی          | Mapped[str]     |
| تنظیمات ستون دیتابیس | mapped_column() |



***relationship:***
- کاربرد relationship  ارتباط بین جدول‌ها در سطح ORM است (نه در سطح دیتابیس مستقیم).
- در اینجا:  province = relationship("Province", ...) یعنی هر City به یک Province تعلق دارد.
- در نتیجه SQLAlchemy می‌دونه که برای گرفتن Province یک City، باید به province_id نگاه کنه(ForeignKey)

***back_populates:***
- دستور back_populates="cities" به SQLAlchemy میگه که ارتباط دوطرفه است:

- از سمت Province می‌توانیم همه Cityهای مربوطه را با province.cities ببینیم.
- از سمت City می‌توانیم استان خودش را با city.province ببینیم.

حال کد زیر را به مدل provinces اضافه می کنیم:


```python
cities = relationship("City", back_populates="province")
```


**شمای(Schema) City:


```python
from pydantic import BaseModel as PydanticBase, Field
from datetime import datetime

class CityCreate(PydanticBase):
    city: str = Field(..., min_length=2, max_length=100)
    province_id: int

class CityOut(CityCreate):
    id: int
    city: str
    province_id: int
    created_at: datetime
```


## فاز پنجم: همه عملیات موجود در پایگاه داده رابطه ای و غیررابطه ای را در قالب یک وب سرویس بصورت API ایجاد کنید.

در این فاز یک وب‌سرویس مبتنی بر API طراحی و پیاده‌سازی شد که امکان مدیریت کامل داده‌ها در پایگاه داده رابطه‌ای را فراهم می‌کند. این ساختار، پایه‌ای مناسب برای توسعه لایه‌های بالاتر سیستم و اتصال به کلاینت‌های مختلف مانند وب یا موبایل محسوب می‌شود.
وب‌سرویس طراحی‌شده شامل مجموعه‌ای از Endpointها است که امکان انجام عملیات پایه پایگاه داده (CRUD) را فراهم می‌کند. این عملیات شامل موارد زیر است:

- **ایجاد رکورد جدید** در جداول پایگاه داده
- **دریافت اطلاعات** به‌صورت تکی یا لیستی
- **به‌روزرسانی اطلاعات موجود** بر اساس شناسه
- **حذف رکوردها** از پایگاه داده

تمامی این عملیات از طریق متدهای استاندارد HTTP مانند `GET`، `POST`، `PUT` و `DELETE` پیاده‌سازی شده‌اند.

**اعتبارسنجی داده‌ها**
برای جلوگیری از ورود داده‌های نامعتبر به پایگاه داده، از مدل‌های Pydantic استفاده شده است. این مدل‌ها ساختار داده‌های ورودی را مشخص کرده و پیش از پردازش درخواست‌ها، صحت نوع و مقدار داده‌ها را بررسی می‌کنند. این موضوع نقش مهمی در افزایش پایداری و امنیت سامانه دارد.

**مدیریت خطا و پاسخ‌ها**
در پیاده‌سازی API، مدیریت خطاها به‌صورت اصولی انجام شده است. در صورت بروز خطاهایی مانند عدم وجود رکورد مورد نظر یا ارسال داده نامعتبر، پاسخ مناسب به همراه کد وضعیت HTTP مرتبط به کاربر بازگردانده می‌شود. این موضوع باعث شفافیت ارتباط بین کلاینت و سرور می‌گردد.

**مستندسازی وب‌سرویس**
یکی از مزایای استفاده از FastAPI، تولید خودکار مستندات تعاملی است. مستندات API به‌صورت گرافیکی از طریق مسیر زیر در دسترس قرار دارد:

```
/docs
```

این مستندات امکان بررسی Endpointها، مشاهده ساختار داده‌ها و تست مستقیم API را فراهم می‌کند.
```python
from fastapi import APIRouter, HTTPException, Query
from sqlalchemy import select
from ..db import SessionDep
from ..models.cities import City
from ..models.provinces import Province
from ..schemas.cities import CityCreate, CityOut
from ..schemas.pagination import Page, paginate

router = APIRouter(prefix="/cities", tags=["City"])

@router.post("/", response_model=CityOut, status_code=201)
def create_city(
    session: SessionDep,
    city: CityCreate,
):
    # -------- check province exists --------
    province = session.get(Province, city.province_id)
    if not province:
        raise HTTPException(status_code=404, detail="Province not found")
    
    # -------- prevent duplicate city in same province --------
    exists = session.execute(
        select(City).where(City.city == city.city, City.province_id == city.province_id)
    ).scalar_one_or_none()

    if exists:
        raise HTTPException(
            status_code=409, detail="City already exists in this province."
        )
        
    city_obj = City(
        city=city.city,
        province_id=city.province_id
    )
    session.add(city_obj)
    session.commit()
    session.refresh(city_obj)
    return city_obj

@router.get("/", response_model=Page[CityOut])
def get_all_cities(
    session: SessionDep,
    page: int = Query(1, ge=1),
    size: int = Query(50, ge=1, le=100),
    search: str | None = None,
    province_id: int | None = None,
    sort_by: str | None = Query(None),
    sort_order: str | None = Query(None, pattern="^(asc|desc)$"),
):
    stmt = select(City)

    # -------- filter by province --------
    if province_id:
        stmt = stmt.where(City.province_id == province_id)

    # -------- search --------
    if search:
        stmt = stmt.where(City.city.ilike(f"%{search}%"))

    # -------- sorting --------
    allowed_sorts = ["id", "city", "created_at", "province_id"]
    if sort_by in allowed_sorts:
        column = getattr(City, sort_by)
        if sort_order == "desc":
            column = column.desc()
        stmt = stmt.order_by(column)

    # -------- pagination --------
    total, pages, items = paginate(session, stmt, page, size)

    return {
        "total": total,
        "size": size,
        "pages": pages,
        "items": items,
    }

@router.delete("/{city_id}")
def delete_city(
    session: SessionDep,
    city_id: int,
):
    city = session.get(City, city_id)

    if not city:
        raise HTTPException(
            status_code=404,
            detail="City not found."
        )

    city_name = city.city
    session.delete(city)
    session.commit()

    return {"detail": f"City {city_id}: {city_name} deleted successfully"}
```


در ابتدای فایل، یک Router با تنظیمات زیر ایجاد شده است:


`prefix="/cities"

تمام آدرس‌های این بخش با /cities/ آغاز می‌شوند.

`tags=["City"]

این برچسب برای دسته‌بندی Routeها در مستندات Swagger استفاده می‌شود.

این ساختار باعث خوانایی بیشتر کد و جداسازی منطقی APIهای مربوط به شهرها از سایر بخش‌های سیستم می‌شود.

***ایجاد شهر جدید (Create City):***
این Route با متد POST امکان افزودن یک شهر جدید به پایگاه داده را فراهم می‌کند. داده‌های ورودی از طریق مدل CityCreate دریافت می‌شوند و پاسخ نهایی در قالب CityOut بازگردانده می‌شود.

**مراحل اجرای منطق:**
- بررسی وجود استان: ابتدا بررسی می‌شود که استان مربوط به province_id ارسال‌شده وجود داشته باشد.در صورت عدم وجود استان، خطای 404 Not Found بازگردانده می‌شود.
- جلوگیری از ثبت شهر تکراری: بررسی می‌شود که شهری با همان نام در همان استان قبلاً ثبت نشده باشد.در صورت وجود شهر تکراری، خطای 409 Conflict برگردانده می‌شود.
- ایجاد و ذخیره شهر:در صورت معتبر بودن داده‌ها، شیء شهر ساخته شده و در پایگاه داده ذخیره می‌شود.
- بازگرداندن نتیجه: پس از ذخیره موفق، اطلاعات شهر ایجادشده به‌عنوان پاسخ API ارسال می‌گردد.

**هدف:**
حفظ یکپارچگی داده‌ها و جلوگیری از ثبت اطلاعات نادرست یا تکراری در پایگاه داده.


***دریافت لیست شهرها (Get All Cities):***
این Route با متد GET برای دریافت لیست شهرها طراحی شده و از قابلیت‌های پیشرفته مانند صفحه‌بندی، فیلتر، جستجو و مرتب‌سازی پشتیبانی می‌کند.

**قابلیت‌های پیاده‌سازی‌شده:

**1. صفحه‌بندی (Pagination)**
پارامتر page: شماره صفحه
پارامتر size: تعداد آیتم در هر صفحه
این قابلیت باعث بهینه‌سازی پاسخ‌ها در دیتاست‌های بزرگ می‌شود.

**2. فیلتر بر اساس استان**
با استفاده از province_id می‌توان فقط شهرهای مربوط به یک استان خاص را دریافت کرد.

**3. جستجوی متنی**
پارامتر search امکان جستجو بر اساس نام شهر را فراهم می‌کند.
جستجو به‌صورت غیرحساس به حروف بزرگ و کوچک انجام می‌شود.

**4. مرتب‌سازی (Sorting)**
کاربر می‌تواند داده‌ها را بر اساس ستون‌های مجاز مانند:
id
city
created_at
province_id

و با ترتیب asc یا desc دریافت کند.

**5. خروجی ساخت‌یافته**
پاسخ نهایی شامل اطلاعات زیر است:
تعداد کل رکوردها
تعداد صفحات
اندازه هر صفحه
لیست شهرهای صفحه جاری

**هدف:**
افزایش انعطاف‌پذیری API و فراهم‌کردن امکان دریافت داده‌ها به‌صورت هدفمند و بهینه.

***حذف شهر (Delete City):***
این Route با متد DELETE برای حذف یک شهر مشخص بر اساس شناسه (city_id) استفاده می‌شود.


**مراحل اجرا:**
- بررسی وجود شهر در پایگاه داده
- در صورت عدم وجود، بازگرداندن خطای 404 Not Found
- در صورت وجود، حذف شهر و ثبت تغییرات
- ارسال پیام موفقیت‌آمیز به کاربر

**هدف:**
مدیریت کامل چرخه عمر داده‌ها و امکان حذف رکوردهای غیرضروری از پایگاه داده.

در این بخش از پروژه، APIهای مربوط به مدیریت شهرها به‌صورت کاملاً ساخت‌یافته، امن و قابل توسعه پیاده‌سازی شده‌اند. استفاده از اعتبارسنجی، مدیریت خطا، صفحه‌بندی و فیلترگذاری، این APIها را برای استفاده در پروژه‌های واقعی و مقیاس‌پذیر مناسب می‌سازد.



## فاز ششم: یک دامین ir . با نام و فامیلی خودتان تهیه کنید. یک حساب کاربری در CloudFlare ایجاد کنید و مدیریت دامنه را به آنجا منتقل کنید.


در این مرحله یک دامنه با پسوند `ir.` به نام زیر از ایرنیک تهیه شد:


- **Domain:** `saeedhaghnazari.ir

سپس:

- یک حساب کاربری در Cloudflare ایجاد شد
- سپس Nameserver های Cloudflare به دامنه منتقل گردید.
- در آخر رکورد های DNS برای اتصال به IP سرور تنظیم شد.

مدیریت DNS دامنه از طریق Cloudflare انجام شده و دامنه از رجیسترار ایرنیک به Nameserverهای Cloudflare منتقل شده است.

**نقشه کلی راه:**

```scss
Domain (ایرنیک)
   ↓
Cloudflare (DNS + SSL)
   ↓
Nginx: Parspack (Port 80 / 443)
   ↓
FastAPI + PostgreSQL (Dockerized)
```


![](./images/1.jpg)

![](./images/2.jpg)

![](./images/3.jpg)

![](./images/4.jpg)

![](./images/5.1.jpg)

![](./images/5.jpg)





## فاز هفتم: یک سرور مجازی لینوکسی را برای بازه کوتاهی اجاره کنید و وب سرویس را در قالب API بر روی سرور روی دامنه اجرا کنید.

در این مرحله یک سرور ابری لینوکسی از Parspack تهیه شد، Docker و Docker Compose نصب شد، دیتابیس PostgreSQL و Backend FastAPI به‌صورت containerized اجرا شدند، Nginx به‌عنوان reverse proxy تنظیم شد و دامنه از طریق Cloudflare به سرور متصل گردید.


![](./images/8.jpg)

![](./images/10.jpg)


***مراحل انجام کار:***

- **اتصال به سرور**

```Powershell
ssh root@171.22.26.38
```

- **آپدیت و آماده‌سازی سیستم**
```bash
apt update && apt upgrade -y
apt install -y git curl ufw
```

- **فعال‌سازی فایروال**
```bash
ufw allow OpenSSH
ufw allow 80
ufw allow 443
ufw enable
```

- **نصب Docker**
```bash
curl -fsSL https://get.docker.com | sh
```

- **نصب و تنظیم Nginx**
```bash
apt install -y nginx
```


- **اتصال دامنه به سرور (Cloudflare)**
![](./images/16.jpg)

***محیط سرور:***
- سیستم عامل: Ubuntu 22.04 LTS
- منابع سرور: 2 vCPU، 4 GB RAM، 25 GB Disk
- پورت‌های باز و مورد استفاده: 80 (HTTP) و 443 (HTTPS)
- نرم‌افزارها و سرویس‌ها: Docker, Docker Compose, Nginx




## فاز هشتم: از طریق بستر Github یا فایل های سورس پروژه را از IDE به Repository خود Push کنید و بر روی سرور خود Clone کنید.

در این فاز هدف، انتقال سورس پروژه از محیط توسعه (IDE) به مخزن GitHub و سپس کپی آن روی سرور واقعی بود تا بتوانیم پروژه را به‌صورت قابل استقرار مدیریت کنیم.

***مراحل انجام کار***

**۱. ایجاد مخزن GitHub**
- ابتدا یک مخزن (Repository) جدید در GitHub ایجاد شد.
- دسترسی لازم برای Push و Pull از طریق HTTPS یا SSH تنظیم گردید.

 **۲. آماده‌سازی پروژه برای Git**
- در محیط IDE (مثل VSCode)، پروژه با دستور زیر به یک مخزن محلی Git تبدیل شد:
`git init git add . git commit -m "Initial commit"`
**۳. اتصال به مخزن GitHub**
- آدرس مخزن GitHub به مخزن محلی اضافه شد:    

`git remote add origin git@github.com:username/project_name.git`

- سپس سورس پروژه روی GitHub پوش شد:

`git push -u origin main`

 **۴. کلون کردن پروژه روی سرور**
- روی سرور، Git نصب و آماده شد.
- پروژه از مخزن GitHub کلون شد:


`git clone git@github.com:haghnazari/havirkesht.git`

- با این کار، آخرین نسخه سورس پروژه روی سرور در مسیر مشخص موجود شد.

![](./images/49.png)

**۵. بروزرسانی پروژه روی سرور**

- برای بروزرسانی پروژه، کافی است روی سرور دستور زیر اجرا شود:
- 
`cd project_name git pull origin main`

- این دستور آخرین تغییرات موجود در GitHub را روی سرور اعمال می‌کند.



## فاز نهم: پروژه را بر روی سرور مستقر کنید، سپس برای دامنه خود گواهی SSL دریافت و نصب نمایید. در نهایت، اطمینان حاصل کنید که برنامه از طریق HTTPS بهصورت ایمن در دسترس است

**1. راه‌اندازی پروژه با Docker**
- برای اجرای پروژه، از Docker Compose استفاده شد:

`docker compose up -d --build`

- این دستور کانتینرهای پروژه (مثل اپلیکیشن FastAPI و پایگاه داده PostgreSQL) را ایجاد و اجرا کرد.


**2. نصب و پیکربندی Nginx به‌عنوان Reverse Proxy**
- سرویس Nginx روی سرور نصب شد و به‌عنوان پروکسی معکوس برای مدیریت درخواست‌ها و هدایت آن‌ها به کانتینر FastAPI پیکربندی گردید.
- فایل پیکربندی Nginx نمونه:
```
server {
    listen 80;
    server_name saeedhaghnazari.ir www.saeedhaghnazari.ir;

    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl;
    server_name saeedhaghnazari.ir www.saeedhaghnazari.ir;

    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;

    location / {
        proxy_pass http://127.0.0.1:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

**3. دریافت گواهی SSL با Certbot**

-  گواهی SSL رایگان Let’s Encrypt با Certbot برای دامنه صادر شد:
- 
`sudo apt install certbot python3-certbot-nginx sudo certbot --nginx -d example.com -d www.saeedhaghnazari.ir

- و Certbot به‌صورت خودکار فایل‌های پیکربندی Nginx را بروزرسانی کرد و HTTPS فعال شد.

**4. بررسی و اطمینان از دسترسی امن**
- با اجرای دستور `curl -I https://saeedhaghnazari.ir` و مرورگر، بررسی شد که سایت از طریق HTTPS در دسترس است.
- همچنین وضعیت گواهی SSL و اعتبار آن از طریق مرورگر یا سرویس‌های آنلاین مانند SSL Labs بررسی شد.




## فاز دهم: از طریق بستر CI/CD فرایند اجرا بر روی سرور را خودکار کنید . به این معنی که بعد از اعمال هر تغییری در لوکال هاست و پوش کردن آن در گیت هاب ، تغییرات همان لحظه بر روی سرور اعمال شود.

در این فاز هدف اصلی، خودکارسازی فرآیند استقرار پروژه روی سرور بود. به کمک CI/CD، هر تغییر در پروژه که روی لوکال اعمال شود و به مخزن GitHub پوش شود، به صورت خودکار روی سرور Pull شده و اجرا می‌شود. این کار باعث کاهش خطای انسانی و سرعت‌بخشی به توسعه می‌شود.

**مراحل انجام کار***

**۱. ایجاد Workflow در GitHub Actions**
یک فایل Workflow با نام cicd.yaml در مسیر .github/workflows/ ایجاد شد.
این فایل مشخص می‌کند که پس از هر push به شاخه main، عملیات استقرار به صورت خودکار انجام شود.

نمونه فایل cicd.yaml:
```
name: Deploy to Server

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.1
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Deploy via SSH
        run: |
          ssh -o StrictHostKeyChecking=no root@SERVER_IP "
          cd /opt/project_name
          git pull origin main
          docker compose down
          docker compose up -d --build
          "
```

**۲. پیکربندی دسترسی SSH**

یک کلید خصوصی SSH برای اتصال امن GitHub Actions به سرور ساخته و در Secrets مخزن ذخیره شد.
کلید عمومی روی سرور در مسیر ~/.ssh/authorized_keys قرار گرفت تا اجازه دسترسی خودکار داده شود.

**۳. اجرای خودکار روی سرور**
پس از هر Push به شاخه main: دستورات Workflow اجرا شده و آخرین تغییرات از GitHub دریافت می‌شوند.
کانتینرهای Docker پروژه متوقف و دوباره ساخته و اجرا می‌شوند.
سرور همیشه با آخرین نسخه پروژه همگام است.
![](./images/50.png)


